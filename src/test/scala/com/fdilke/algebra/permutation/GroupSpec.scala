package com.fdilke.algebra.permutation

import com.fdilke.utility.RichFunSuite._
import scala.language.postfixOps
import munit.FunSuite

class GroupSpec extends FunSuite:
  test("can calculate powers of an element"):
    val group: Group[Int] = CyclicGroup(9)
    (0 until 9).forall: i =>
      (0 until 9).forall: j =>
        group.power(i, j) == (i*j % 9)
    .is(true)
    (0 until 9).foreach: i =>
      group.power(i, -1) is ((9 - i) % 9)

    test("can calculate the subgroup generated by a subset"):
      val group: Group[Permutation] =
        Permutation.symmetricGroup(3)

      val transposition = Permutation(0, 2, 1)

      group.generateSubgroup() is group.trivialSubgroup

      group.generateSubgroup(
        transposition
      ).elements is Set(
        group.unit,
        transposition
      )

      val rotation = Permutation(1, 2, 0)

      group.generateSubgroup(
        transposition,
        rotation
      ).elements is
        group.elements

  test("can tell if a group is cyclic"):
    CyclicGroup(9).isCyclic is true
    DihedralGroup(4).isCyclic is false
    Permutation.symmetricGroup(3).isCyclic is false

  test("can tell if a group is abelian"):
    CyclicGroup(9).isAbelian is true
    DihedralGroup(4).isAbelian is true
    Permutation.symmetricGroup(3).isAbelian is false

  test("can compute the centre for cyclic groups"):
    val group = CyclicGroup(9)
    group.centre is group.wholeGroup

  test("can compute the centre for symmetric groups"):
    val group = Permutation.symmetricGroup(4)
    group.centre is group.trivialSubgroup

  test("can compute the centre for dihedral groups"):
    val group = DihedralGroup(4)
    group.centre is group.wholeGroup

  test("can compute the centre for bigger dihedral groups"):
    DihedralGroup(6).centre.order is 1
    DihedralGroup(12).centre.order is 2

  test("can compute the order of elements - for cyclic groups"):
    CyclicGroup(9).elementOrders is Map(
      1 -> 1,
      9 -> 6,
      3 -> 2
    )

  test("can compute the order of elements - for dihedral groups"):
    DihedralGroup(6).elementOrders is Map(
      1 -> 1,
      2 -> 3,
      3 -> 2
    )

  test("determine a complement for a subgroup, if there is one"):
    val group9: Group[Int] =
      CyclicGroup(9)
    group9.trivialSubgroup.findComplement is Some(group9.wholeGroup)
    group9.wholeGroup.findComplement is Some(group9.trivialSubgroup)
    val ord3: Int =
      group9.elementOfOrder(3)
    group9.generateSubgroup(ord3).findComplement is None

  test("determine a complement for a subgroup, if there is one (2)"):
    val group6: Group[Permutation] =
      Permutation.symmetricGroup(3)
    val ord3: Permutation =
      group6.elementOfOrder(3)
    val ord2: Permutation =
      group6.elementOfOrder(2)
    group6.generateSubgroup(ord3).findComplement.isDefined is true
    group6.generateSubgroup(ord2).findComplement is Some(group6.generateSubgroup(ord3))

  test("determine a complement for a subgroup, if there is one (3)"):
    val group: Group[Permutation] =
      Permutation.symmetricGroup(4)
    for
      subgroup <- group.subgroups if !Set(2,4).contains(subgroup.order)
    do
      subgroup.findComplement.isDefined is true

  test("determine a complement for a subgroup, if there is one (4)"):
    val group: Group[Permutation] =
      Permutation.alternatingGroup(4)
    for
      subgroup <- group.subgroups
    do
      subgroup.findComplement.isEmpty is (subgroup.order == 2)

  test("enumerating subgroups of the trivial group"):
    val trivialGroup = Permutation.symmetricGroup(1)
    trivialGroup.subgroups is Set(
      trivialGroup.trivialSubgroup
    )

  test("enumerating subgroups of the 2-element group"):
    val twoGroup = Permutation.symmetricGroup(2)
    twoGroup.subgroups is Set(
      twoGroup.trivialSubgroup,
      twoGroup.wholeGroup
    )

  // return the orders of a group's subgroups -
  // with the sign reversed if they're normal!
  // and ordered with the normal subgroups last for each order
  private def subgroupOrdersX[T](group: Group[T]): Seq[Int] =
    group.subgroups.toSeq.map: subgroup =>
      subgroup.order * (
        if (subgroup.isNormal) -1 else +1
      )
    .sortBy: orderX =>
      3 * Math.abs(orderX) - (
        if (orderX > 0) +1 else -1
      )

  test("enumerating subgroups of cyclic groups works - at least orders are correct"):
    subgroupOrdersX(CyclicGroup(6)) is Seq(-1,-2,-3,-6)
    subgroupOrdersX(CyclicGroup(7)) is Seq(-1,-7)
    subgroupOrdersX(CyclicGroup(8)) is Seq(-1,-2,-4,-8)

  test("enumerating subgroups of symmetric groups works"):
    subgroupOrdersX(Permutation.symmetricGroup(3)) is Seq(
      -1, 2, 2, 2, -3, -6
    )

  test("enumerating subgroups of dihedral groups works"):
    subgroupOrdersX(DihedralGroup(12)) is Seq(
      -1, 2, 2, 2, 2, 2, 2, -2, -3, 4, 4, 4, -6, -6, -6, -12
    )

  test("can compute stabilizers in a permutation group"):
    val group: Group[Permutation] =
      Permutation.symmetricGroup(4)
    group.stabilizer() is group.wholeGroup
    group.stabilizer(0).order is 6
    group.stabilizer(0, 1).order is 2
    group.stabilizer(0, 1, 2) is group.trivialSubgroup
    group.stabilizer(0, 1, 2, 3) is group.trivialSubgroup

  test("can compute conjugacy classes"):
    def classSizes[T](group: Group[T]): Seq[Int] =
      group.conjugacyClasses.toSeq.map { _.size }.sorted
    classSizes(CyclicGroup(2)) is Seq(1, 1)
    classSizes(CyclicGroup(3)) is Seq(1, 1, 1)
    classSizes(Permutation.symmetricGroup(3)) is Seq(1, 2, 3)
    classSizes(DihedralGroup(4)) is Seq(1, 1, 1, 1)

  test("can compute if a group is simple"):
    CyclicGroup(2).isSimple is true
    CyclicGroup(3).isSimple is true
    CyclicGroup(4).isSimple is false
    Permutation.symmetricGroup(0).isSimple is true
    Permutation.symmetricGroup(3).isSimple is false
    Permutation.alternatingGroup(3).isSimple is true
    Permutation.alternatingGroup(4).isSimple is false
    Permutation.alternatingGroup(5).isSimple is true
    DihedralGroup(2).isSimple is true
    DihedralGroup(4).isSimple is false
    DihedralGroup(6).isSimple is false

  test("can tell if a group is ambivalent"):
    CyclicGroup(1).isAmbivalent is true
    CyclicGroup(2).isAmbivalent is true
    CyclicGroup(3).isAmbivalent is false
    CyclicGroup(9).isAmbivalent is false
    DihedralGroup(4).isAmbivalent is true
    DihedralGroup(6).isAmbivalent is true
    DihedralGroup(8).isAmbivalent is true
    Permutation.symmetricGroup(4).isAmbivalent is true
    Permutation.symmetricGroup(5).isAmbivalent is true
    Permutation.alternatingGroup(4).isAmbivalent is false
    Permutation.alternatingGroup(5).isAmbivalent is true

  test("can tell if a group is strongly ambivalent"):
    CyclicGroup(1).isStronglyAmbivalent is true
    CyclicGroup(2).isStronglyAmbivalent is true
    CyclicGroup(3).isStronglyAmbivalent is false
    CyclicGroup(9).isStronglyAmbivalent is false
    DihedralGroup(4).isStronglyAmbivalent is true
    DihedralGroup(6).isStronglyAmbivalent is true
    DihedralGroup(8).isStronglyAmbivalent is true
    Permutation.symmetricGroup(4).isStronglyAmbivalent is true
    Permutation.symmetricGroup(5).isStronglyAmbivalent is true
    Permutation.symmetricGroup(5).isStronglyAmbivalent is true
    Permutation.alternatingGroup(4).isStronglyAmbivalent is false
    Permutation.alternatingGroup(5).isStronglyAmbivalent is false

  test("can compute coset representatives of a subgroup"):
    val group: Group[Permutation] =
      Permutation.symmetricGroup(3)
    val subgroup2: group.Subgroup =
      group.generateSubgroup(Permutation(1, 0, 2))
    subgroup2.order is 2
    val reps: Seq[Permutation] =
      subgroup2.rightCosetRepresentatives
    reps.size is 3
    val cosetUnion: Set[Permutation] =
      for
        r <- reps.toSet
        s <- subgroup2.elements
      yield
          group.multiply(r, s)
    cosetUnion.size is 6

  test("can compute quotients by a normal subgroup"):
    val group: Group[Permutation] =
      Permutation.symmetricGroup(3)
    val alternating: group.Subgroup =
      group.generateSubgroup(Permutation(1, 2, 0))
    val quotient: Group[Permutation] =
      group / alternating
    GroupVerifier.checkGroupOf[Permutation](quotient)
    quotient.order is 2

  test("can compute the quotients of S_4".ignore):
    val group: Group[Permutation] =
      Permutation.symmetricGroup(4)
    group.subgroups.filter:
      _.isNormal
    .map: subgroup =>
      println(s"subgroup order = ${subgroup.order}")
      val quotient: Group[Permutation] =
        group/subgroup
      GroupVerifier.checkGroupOf[Permutation](quotient)
      (quotient.order * subgroup.order) is group.order
      subgroup.order
    .is:
      Set(1,4,12,24)
