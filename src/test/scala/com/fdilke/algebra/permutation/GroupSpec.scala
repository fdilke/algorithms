package com.fdilke.algebra.permutation

import com.fdilke.utility.RichFunSuite._
import scala.language.postfixOps
import munit.FunSuite

class GroupSpec extends FunSuite:
  test("can calculate the subgroup generated by a subset"):
    val group: Group[Permutation] =
      Permutation.group(3)

    val transposition = Permutation(0, 2, 1)

    group.generateSubgroup() is group.trivialSubgroup

    group.generateSubgroup(
      transposition
    ).elements is Set(
      group.unit,
      transposition
    )

    val rotation = Permutation(1, 2, 0)

    group.generateSubgroup(
      transposition,
      rotation
    ).elements is
      group.elements

  test("can tell if a group is cyclic"):
    CyclicGroup(9).isCyclic is true
    DihedralGroup(4).isCyclic is false
    Permutation.group(3).isCyclic is false

  test("can tell if a group is abelian"):
    CyclicGroup(9).isAbelian is true
    DihedralGroup(4).isAbelian is true
    Permutation.group(3).isAbelian is false

  test("can compute the centre for cyclic groups"):
    val group = CyclicGroup(9)
    group.centre is group.wholeGroup

  test("can compute the centre for symmetric groups"):
    val group = Permutation.group(4)
    group.centre is group.trivialSubgroup

  test("can compute the centre for dihedral groups"):
    val group = DihedralGroup(4)
    group.centre is group.wholeGroup

  test("can compute the centre for bigger dihedral groups"):
    DihedralGroup(6).centre.order is 1
    DihedralGroup(12).centre.order is 2

  test("can compute the order of elements - for cyclic groups"):
    elementOrders(CyclicGroup(9)) is Seq(
      1, 3, 3, 9, 9, 9, 9, 9, 9
    )

  test("can compute the order of elements - for dihedral groups"):
    elementOrders(DihedralGroup(6)) is Seq(
      1, 2, 2, 2, 3, 3
    )

  private def elementOrders[T](group: Group[T]): Seq[Int] =
    group.elements.toSeq.map:
      group.orderOf
    .sorted
